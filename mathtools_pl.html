<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" charset="utf-8" content="width=device-width, initial-scale=1"/>
  <link rel="stylesheet" type="text/css" href="style.css"/>
  <title>Gnoun - Matematyczne Narzędzia</title>
</head>
<body>
  <a id="top"></a>
  <div class="topnav">
    <a href="index_pl.html"><strong>Strona Główna</strong></a>
    <a href="sup_pl.html"><strong>Co nowego</strong></a>
    <a href="graphs_pl.html"><strong>Wykresy</strong></a>
    <a class="active" href="mathtools_pl.html"><strong>Matematyczne Narzędzia</strong></a>
    <a href="music_pl.html"><b>Muzyka</b></a>
  </div>

  <div class="content">
    <h1>Matematyczne Narzędzia</h1>
    Oto zestaw przydatnych narzędzi matematycznych, które mogą Ci pomóc w przeróżnych sytuacjach.
    <br><br>Parę uwag dotyczących narzędzi:
    <ul>
    <li>Jeśli napotkasz wyrażenie "NaN", jest ono skrótem od "Not a Number"; w większości przypadkow, znaczy to, że wszystkie wymagane luki zostały wypełnione. W przeciwnym razie wynik faktycznie nie jest liczbą.</li>
    <li>Czasem javascript nie daje rady precyzyjnie oszacować rozwinięć dziesiętnych wyników, więc sugerowane jest korzystanie z maks. 8-10 cyfr po przecinku. Jeśli znasz inne rozwiązanie tego problemu, skontaktuj się ze mną.</li>
    </ul>

    <br>

    <table>
      <tr>
        <th>Spis Treści</th>
      </tr>
      <tr>
        <td><!--0. <a href="#bottom">Bottom of the Table of Contents</a>
        <br>-->1. <strong>Liczby ogólnie</strong>
        <br>&nbsp a. <a href="#gcf">Największy Wspólny Dzielnik</a>
        <br>&nbsp b. <a href="#lcm">Najmniejsza Wspólna Wielokrotność</a>
        <br>2. <strong>Geometria Analityczna</strong>
        <br>&nbsp A. Wektory
        <br>&nbsp&nbsp a. <a href="#magnitude">Długość Wektora</a>
        <br>&nbsp&nbsp b. <a href="#vector_cartesian_to_polar">Konwerter postaci kartezjańskiej do biegunowej</a>
        <br>&nbsp&nbsp c. <a href="#vector_polar_to_cartesian">Konwertej postaci biegunowej do kartezjańskiej</a>
        <br>&nbsp B. Inne
        <br>&nbsp&nbsp a. <a href="#distance_between_points">Odległość Między Punktami</a>
        <br>&nbsp&nbsp b. <a href="#midpoint">Środek Odcinka</a>
        <br>&nbsp&nbsp c. <a href="#distance_between_lines">Odległość Między Prostymi</a>
        <br>&nbsp&nbsp d. <a href="#distance_between_line_and_point">Odległość Pomiędzy Punktem a Prostą</a>
        <!--<br>&nbsp&nbsp e. Belongingness of a Point to a Circle-->
        <br>3. <strong>Liczby Zespolone</strong>
        <br>&nbsp a. <a href="#complex_division">Dzielenie Zespolone (postać kanoniczna)</a>
        <br>&nbsp b. <a href="#complex_division_polar">Dzielenie Zespolone (postać biegunowa)</a>
        <br>&nbsp c. <a href="#complex_rectangular_to_polar">Konwerter postaci kanonicznej do biegunowej</a>
        <br>&nbsp d. <a href="#complex_polar_to_rectangular">Konwerter postaci biegunowej do kanonicznej</a>
        <br>4. <a href="#external">Linki zewnętrzne</a>
      </tr>
    </table>

    <a id="bottom"></a>
    <!--<h3>Bottom of the Table of Contents</h3>
    You've made it to the bottom of the table of contents! --><br>Każde narzędzie zawiera pod sobą wyjaśnienie i więcej informacji w linku. Zawsze możesz powrócić na samą górę strony poprzez kliknięcie w mały przycisk "powrót na górę" znajdujący się pod każdym z narzędzi.

    <br><br>
    <font size=2><a href="#top">Powrót na górę</a></font><br><br><hr>

    <a id="gcf"></a>
    <h2>Największy Wspólny Dzielnik</h2>

    <br>Liczba #1: <input type=number id="ba">
    <br>Liczba #2: <input type=number id="bb">

    <br><br>NWD: <font id="xi"></font>

    <script>
      let ba = document.getElementById("ba");
      let bb = document.getElementById("bb");
      let xi = document.getElementById("xi");
      ba.addEventListener('input', function (evt) {
        xi.innerText = GCF(parseInt(ba.value),parseInt(bb.value));
      });
      bb.addEventListener('input', function (evt) {
        xi.innerText = GCF(parseInt(ba.value),parseInt(bb.value));
      });
      function GCF(p1, p2) {
        if(p1 == 0) return p2;
        else if(p2 == 0) return p1;
        else {
          var p3 = p1 % p2;
          return GCF(p2,p3);
        }
      }
    </script>

    <br><br><br>Wyjaśnienie:
    <p>Dla dwóch liczb A i B, wspólnym dzielnikiem liczb A i B jest taka liczba C, że zarówno A/C, jak i B/C są liczbami naturalnymi. Największy Wspólny Dzielnik jest największym możliwym C.
    <br><br><a href="https://pl.wikipedia.org/wiki/Najwi%C4%99kszy_wsp%C3%B3lny_dzielnik" target="_blank">Więcej informacji</a>
    <br><br><font size=2><a href="#top">Powrót na górę</a></font><br><hr>

    <a id="lcm"></a>
    <h2>Najmniejsza Wspólna Wielokrotność</h2>

    <br>Liczba #1: <input type=number id="bc">
    <br>Liczba #2: <input type=number id="bd">

    <br><br>NWW: <font id="xj"></font>

    <script>
      let bc = document.getElementById("bc");
      let bd = document.getElementById("bd");
      let xj = document.getElementById("xj");
      bc.addEventListener('input', function (evt) {
        xj.innerText = LCM(parseInt(bc.value),parseInt(bd.value));
      });
      bd.addEventListener('input', function (evt) {
        xj.innerText = LCM(parseInt(bc.value),parseInt(bd.value));
      });
      function LCM(p1, p2) {
        var p3 = p2/GCF(p1,p2);
        return p1*p3;
      }
    </script>

    <br><br><br>Wyjaśnienie:
    <p>Dla dwóch liczb A i B, wspólną wielokrotnością liczb A i B jest taka liczba C, że zarówno C/A, jak i C/B są liczbami naturalnymi. Najmniejsza Wspólna Wielokrotność to najmniejsze możliwe C.
    <br><br><a href="https://pl.wikipedia.org/wiki/Najmniejsza_wsp%C3%B3lna_wielokrotno%C5%9B%C4%87" target="_blank">Więcej informacji</a>
    <br><br><font size=2><a href="#top">Powrót na górę</a></font><br><hr>

    <a id="magnitude"></a>
    <h2>Długość Wektora</h2>

    <form oninput="x.value = Math.sqrt(Math.pow(parseFloat(a.value), 2) + Math.pow(parseFloat(b.value), 2))">

      <font size = 4> Współrzędne wektora: <br></font>
      x = <input type="number" id="a" size="40"> y = <input type="number" id="b">

      <br><br>

      <font size = 4> Wynik: </font>
      <output name="x" for="a b"></output>
    </form>

    <br><br>Wyjaśnienie:
    <p>Aby obliczyć długość wektora, należy pomyśleć o współrzędnych x i y jako długościach przyprostokątnych trójkąta prostokątnego, w którym przeciwprostokątną jest właśnie długość wektora. Zastosuj Twierdzenie Pitagorasa aby ją obliczyć.
    <br><br><a href="https://pl.wikipedia.org/wiki/Wektor#D%C5%82ugo%C5%9B%C4%87" target="_blank">Więcej informacji</a>
    <br><br>Zobacz też: <a href="#distance_between_points">Odległość Pomiędzy Punktami</a>
    <br><br><font size=2><a href="#top">Powrót na gorę</a></font><br><hr>

    <a id="vector_cartesian_to_polar"></a>
    <h2>Konwerter wektora z postaci kartezjańskiej do biegunowej</h2>

    <iframe src="https://www.desmos.com/calculator/3bpeokqlk2?embed" width="250px" height="250px" style="border: 1px solid #ccc" frameborder=0></iframe>
    <br><br>

    <font size = 4> Postać kartezjańska: <br></font>
    x = <input type="number" id="t"><br> y = <input type="number" id="u">

    <br><br>

    <font size = 4> Postać biegunowa: <br></font>
    r = <font id="xc"></font><br> θ = <font id="yc"></font>°

    <script>
    let t = document.getElementById("t");
    let u = document.getElementById("u");
    let xc = document.getElementById("xc");
    let yc = document.getElementById("yc");
    t.addEventListener('input', function (evt) {
      xc.innerText = Math.sqrt(Math.pow(parseFloat(t.value), 2) + Math.pow(parseFloat(u.value), 2));
      if ((parseFloat(t.value) > 0) && (parseFloat(u.value) > 0)) { yc.innerText = Math.atan(parseFloat(u.value)/parseFloat(t.value))*180/Math.PI; }
      else if ((parseFloat(t.value) > 0) && (parseFloat(u.value) < 0)) { yc.innerText = Math.atan(parseFloat(u.value)/parseFloat(t.value))*180/Math.PI + 360; }
      else { yc.innerText = Math.atan(parseFloat(u.value)/parseFloat(t.value))*180/Math.PI + 180; }
    });
    u.addEventListener('input', function (evt) {
      xc.innerText = Math.sqrt(Math.pow(parseFloat(t.value), 2) + Math.pow(parseFloat(u.value), 2));
      if ((parseFloat(t.value) > 0) && (parseFloat(u.value) > 0)) { yc.innerText = Math.atan(parseFloat(u.value)/parseFloat(t.value))*180/Math.PI; }
      else if ((parseFloat(t.value) > 0) && (parseFloat(u.value) < 0)) { yc.innerText = Math.atan(parseFloat(u.value)/parseFloat(t.value))*180/Math.PI + 360; }
      else { yc.innerText = Math.atan(parseFloat(u.value)/parseFloat(t.value))*180/Math.PI + 180; }
    });
    </script>

    <br><br>Wyjaśnienie:
    <p>Aby zamienić współrzędne kartezjańskie na <a href="https://pl.wikipedia.org/wiki/Uk%C5%82ad_wsp%C3%B3%C5%82rz%C4%99dnych_biegunowych" target="_blank">współrzędne biegunowe</a>, należy oddzielnie obliczyć promień <i>r</i> i kąt <i>θ</i>. Promień jest równy długości wektora, więc aby go uzyskać po prostu stosujemy wzór na <a href="#magnitude">długość wektora</a>. Aby uzyskać <i>θ</i>, szukamy kąta, którego tangens jest równy <i>y</i> dzielone przez <i>x</i>.
    <br><i>Uwaga poboczna: Można również użyć tego narzedzia jako konwerter punktów.</i>
    <br><br><a href="https://pl.khanacademy.org/math/precalculus/x9e81a4f98389efdf:vectors/x9e81a4f98389efdf:magnitude-direction/a/vector-forms-review" target="_blank">Więcej informacji</a>
    <br><br>Zobacz też: <a href="#vector_polar_to_cartesian">Konwerter wektora z postaci biegunowej do postaci kanonicznej</a>, <a href="#complex_cartesian_to_polar">Konwerter liczb zespolonych z postaci kanonicznej do biegunowej</a>
    <br><br><font size=2><a href="#top">Powrót na górę</a></font><br><hr>

    <a id="vector_polar_to_cartesian"></a>
    <h2>Konwerter wektora z postaci biegunowej do kartezjańskiej</h2>

    <iframe src="https://www.desmos.com/calculator/zcpene3ue0?embed" width="250px" height="250px" style="border: 1px solid #ccc" frameborder=0></iframe>
    <br><br>

    <font size = 4> Postać biegunowa: <br></font>
    r = <input type="number" id="aa"><br> θ = <input type="number" id="ab">°

    <br><br>

    <font size = 4> Postać kartezjańska: <br></font>
    x = <font id="xd"></font><br> y = <font id="yd"></font>

    <script>
    let aa = document.getElementById("aa");
    let ab = document.getElementById("ab");
    let xd = document.getElementById("xd");
    let yd = document.getElementById("yd");
    aa.addEventListener('input', function (evt) {
      xd.innerText = parseFloat(aa.value)*Math.cos(parseFloat(ab.value)*Math.PI/180);
      yd.innerText = parseFloat(aa.value)*Math.sin(parseFloat(ab.value)*Math.PI/180);
    });
    ab.addEventListener('input', function (evt) {
      xd.innerText = parseFloat(aa.value)*Math.cos(parseFloat(ab.value)*Math.PI/180);
      yd.innerText = parseFloat(aa.value)*Math.sin(parseFloat(ab.value)*Math.PI/180);
    });
    </script>

    <br><br>Wyjaśnienie:
    <p>Aby zamienić współrzędne biegunowe na współrzędne kartezjańskie, należy pomyśleć o <i>x</i>, <i>y</i> i <i>r</i> jako bokach trójkąta prostokątnego, gdzie <i>r</i> jest przeciwprostokątną. Aby znaleźć <i>x</i> i <i>y</i>, korzystamy z dwóch funkcji trygonometrycznych, odpowiednio cosinus i sinus.
    <br><i>Uwaga poboczna: Można również użyć tego narzedzia jako konwerter punktów.</i>
    <br><br><a href="https://pl.khanacademy.org/math/precalculus/x9e81a4f98389efdf:vectors/x9e81a4f98389efdf:magnitude-direction/a/vector-forms-review" target="_blank">Więcej informacji</a>
    <br><br>Zobacz też: <a href="#vector_cartesian_to_polar">Konwerter wektora z postaci kartezjańskiej do biegunowej</a>, <a href="#complex_polar_to_cartesian">Konwerter liczby zespolonej z postaci biegunowej na kanoniczną</a>
    <br><br><font size=2><a href="#top">Powrót na górę</a></font><br><hr>

    <a id="distance_between_points"></a>
    <h2> Odległość Między Punktami </h2>

    <iframe src="https://www.desmos.com/calculator/jg0sr9tntb?embed" width="250px" height="250px" style="border: 1px solid #ccc" frameborder=0></iframe>
    <br><br>

    <form oninput="x.value = Math.sqrt(Math.pow(parseFloat(c.value)-parseFloat(a.value), 2)+Math.pow(parseFloat(d.value)-parseFloat(b.value), 2))">

      <font size = 4> Punkt A <br></font>
      x = <input type="number" id="a" size="40"> y = <input type="number" id="b">

      <br><br>

      <font size = 4> Punkt B <br></font>
      x = <input type="number" id="c"> y = <input type="number" id="d">

      <br><br>

      <font size = 4> Odległość: </font>
      <output name="x" for="a b c d"></output>
    </form>

      <br><br>Wyjaśnienie:
      <p>Aby obliczyć odległość pomiędzy dwoma punktami, musimy najpierw obliczyć odległość pomiędzy współrzędnymi X (dx) oraz współrzędnymi y (dy) tych punktów. Następnie, stosujemy Twierdzenie Pitagorasa (dx i dy są przyprostokątnymi trójkąta prostokątnego, a odległość pomiędzy A i B jest przeciwprostokątną) i obliczamy pierwiastek z sumy kwadratów dx i dy.
      <br><br><a href="https://www.matemaks.pl/dlugosc-odcinka-w-ukladzie-wspolrzednych.html" target="_blank">Więcej informacji</a>
      <br><br><font size=2><a href="#top">Powrót na górę</a></font><br><hr>

      <a id="midpoint"></a>
      <h2> Środek Odcinka </h2>

      <iframe src="https://www.desmos.com/calculator/odbbpcnccy?embed" width="250px" height="250px" style="border: 1px solid #ccc" frameborder=0></iframe>
      <br><br>

      <font size = 4> Punkt A <br></font>
      a = <input type="number" id="e"> b = <input type="number" id="f">

      <br><br>

      <font size = 4> Punkt B <br></font>
      c = <input type="number" id="g"> d = <input type="number" id="h">

      <br><br>

      <font size = 4> Środek Odcinka: ( <font id="xa"></font> , <font id="ya"></font> )</font>

      <script>
        let xa = document.getElementById("xa");
        let ya = document.getElementById("ya");
        let e = document.getElementById("e");
        let f = document.getElementById("f");
        let g = document.getElementById("g");
        let h = document.getElementById("h");
        e.addEventListener('input', function (evt) {
            xa.innerText = (parseFloat(e.value) + parseFloat(g.value))/2;
        });
        f.addEventListener('input', function (evt) {
            ya.innerText = (parseFloat(h.value) + parseFloat(f.value))/2;
        });
        g.addEventListener('input', function (evt) {
            xa.innerText = (parseFloat(e.value) + parseFloat(g.value))/2;
        });
        h.addEventListener('input', function (evt) {
            ya.innerText = (parseFloat(h.value) + parseFloat(f.value))/2;
        });
      </script>

      <br><br><br>Wyjaśnienie:
      <p>Aby obliczyć współrzędne punktu pomiędzy dwoma punktami - czyli środek odcinka między tymi punktami - obliczamy oddzielnie średnią współrzędnych X i współrzędnych Y obu puntków.
      <br><br><a href="https://pl.wikipedia.org/wiki/%C5%9Arodek_odcinka" target="_blank">Więcej informacji</a>
      <br><br><font size=2><a href="#top">Powrót na górę</a></font><br><hr>

      <a id="distance_between_lines"></a>
      <h2> Odległość Między (dwoma równoległymi) Prostymi </h2>

      <iframe src="https://www.desmos.com/calculator/wswjcodgnq?embed" width="250px" height="250px" style="border: 1px solid #ccc" frameborder=0></iframe>
      <br><br>

      <font size = 4><u>Dla prostych w postaci kierunkowej:</u></font><br><br><font size="5">
      y<sub>1</sub> = <input type="number" id="i">x + <input type="number" id="j"><br>
      y<sub>2</sub> = <font id="k"></font>x + <input type="number" id="l"><br><br></font>
      Odległość: <font id="xb"></font>

      <br><br><br>

      <font size = 4><u>Dla prostych w postaci ogólnej:</u></font><br><br><font size="5">
      Prosta 1: <input type="number" id="m">x + <input type="number" id="n">y + <input type="number" id="o"> = 0<br>
      Prosta 2: <font id="r"></font>x + <font id="p"></font>y + <input type="number" id="s"> = 0<br><br></font>
      Odległość: <font id="yb"></font>

      <script>
        let xb = document.getElementById("xb");
        let yb = document.getElementById("yb");
        let i = document.getElementById("i");
        let j = document.getElementById("j");
        let k = document.getElementById("k");
        let l = document.getElementById("l");
        let n = document.getElementById("m");
        let m = document.getElementById("n");
        let o = document.getElementById("o");
        let p = document.getElementById("p");
        let r = document.getElementById("r");
        let s = document.getElementById("s");
        i.addEventListener('input', function (evt) {
          k.innerText = parseFloat(i.value);
          xb.innerText = (Math.abs(parseFloat(l.value)-parseFloat(j.value)))/(Math.sqrt(Math.pow(parseFloat(i.value), 2) + 1));
        });
        j.addEventListener('input', function (evt) {
          xb.innerText = (Math.abs(parseFloat(l.value)-parseFloat(j.value)))/(Math.sqrt(Math.pow(parseFloat(i.value), 2) + 1));
        });
        l.addEventListener('input', function (evt) {
          xb.innerText = (Math.abs(parseFloat(l.value)-parseFloat(j.value)))/(Math.sqrt(Math.pow(parseFloat(i.value), 2) + 1));
        });
        m.addEventListener('input', function (evt) {
          p.innerText = parseFloat(m.value);
          yb.innerText = (Math.abs(parseFloat(s.value)-parseFloat(o.value)))/(Math.sqrt(Math.pow(parseFloat(m.value), 2) + Math.pow(parseFloat(n.value), 2)));
        });
        n.addEventListener('input', function (evt) {
          r.innerText = parseFloat(n.value);
          yb.innerText = (Math.abs(parseFloat(s.value)-parseFloat(o.value)))/(Math.sqrt(Math.pow(parseFloat(m.value), 2) + Math.pow(parseFloat(n.value), 2)));
        });
        o.addEventListener('input', function (evt) {
          yb.innerText = (Math.abs(parseFloat(s.value)-parseFloat(o.value)))/(Math.sqrt(Math.pow(parseFloat(m.value), 2) + Math.pow(parseFloat(n.value), 2)));
        });
        s.addEventListener('input', function (evt) {
          yb.innerText = (Math.abs(parseFloat(s.value)-parseFloat(o.value)))/(Math.sqrt(Math.pow(parseFloat(m.value), 2) + Math.pow(parseFloat(n.value), 2)));
        });
      </script>

      <br><br><br>Wyjaśnienie:
      <p>Najktótszy odcinek pomiędzy dwoma liniami jest do nich prostopadły. Korzystamy z tego faktu, aby obliczyć ogólny wzór na współrzędne dwóch punktów, gdzie każdy z punktów należy do jednej z równoległych linii i tej samej linii prostopadłej. Następnie, korzystamy ze wzoru na <a href="#distance_between_points">ogległość między punktami</a> aby znaleźć i zastosować wzór na odległość pomiędzy dwoma prostymi.
      <br><br><a href="https://pl.wikipedia.org/wiki/R%C3%B3wnoleg%C5%82o%C5%9B%C4%87#:~:text=Odleg%C5%82o%C5%9B%C4%87%20prostych%20r%C3%B3wnoleg%C5%82ych%20%E2%80%93%20odleg%C5%82o%C5%9B%C4%87%20kt%C3%B3regokolwiek,rzutu%20prostopad%C5%82ego%20na%20drug%C4%85%20prost%C4%85.&text=gdy&text=wi%C4%99c" target="_blank">Więcej informacji</a>
      <br><br><font size=2><a href="#top">Powrót na górę</a></font><br><hr>

      <a id="distance_between_line_and_point"></a>
      <h2>Odległość Między Punktem a Prostą</h2>

      <iframe src="https://www.desmos.com/calculator/vxadvyognf?embed" width="250px" height="250px" style="border: 1px solid #ccc" frameborder=0></iframe>
      <br><br>

      <font size = 4><u>Dla prostych w postaci ogólnej:</u></font><br><br><font size="5">
      Prosta: <input type="number" id="be">x + <input type="number" id="bf">y + <input type="number" id="bg"> = 0<br>
      Punkt: (<input type="number" id="bh">, <input type="number" id="bi">)<br><br></font>
      Odległość: <font id="xm"></font>

      <script>
        let be = document.getElementById("be");
        let bf = document.getElementById("bf");
        let bg = document.getElementById("bg");
        let bh = document.getElementById("bh");
        let bi = document.getElementById("bi");
        let xm = document.getElementById("xm");
        be.addEventListener('input', function (evt) {
          xm.innerText = Math.abs(parseFloat(be.value)*parseFloat(bh.value)+parseFloat(bf.value)*parseFloat(bi.value)+parseFloat(bg.value))/Math.sqrt(Math.pow(parseFloat(be.value), 2)+Math.pow(parseFloat(bf.value),2 ));
        });
        bf.addEventListener('input', function (evt) {
          xm.innerText = Math.abs(parseFloat(be.value)*parseFloat(bh.value)+parseFloat(bf.value)*parseFloat(bi.value)+parseFloat(bg.value))/Math.sqrt(Math.pow(parseFloat(be.value), 2)+Math.pow(parseFloat(bf.value),2 ));
        });
        bg.addEventListener('input', function (evt) {
          xm.innerText = Math.abs(parseFloat(be.value)*parseFloat(bh.value)+parseFloat(bf.value)*parseFloat(bi.value)+parseFloat(bg.value))/Math.sqrt(Math.pow(parseFloat(be.value), 2)+Math.pow(parseFloat(bf.value),2 ));
        });
        bh.addEventListener('input', function (evt) {
          xm.innerText = Math.abs(parseFloat(be.value)*parseFloat(bh.value)+parseFloat(bf.value)*parseFloat(bi.value)+parseFloat(bg.value))/Math.sqrt(Math.pow(parseFloat(be.value), 2)+Math.pow(parseFloat(bf.value),2 ));
        });
        bi.addEventListener('input', function (evt) {
          xm.innerText = Math.abs(parseFloat(be.value)*parseFloat(bh.value)+parseFloat(bf.value)*parseFloat(bi.value)+parseFloat(bg.value))/Math.sqrt(Math.pow(parseFloat(be.value), 2)+Math.pow(parseFloat(bf.value),2 ));
        });
      </script>

      <br><br><br>Wyjaśnienie:
      <p>Aby uzyskać wzór na odległość pomiędzy punktem a prostą, należy skorzystać z własności trójkąta, w którym wysokość jest odległością pomiędzy punktem a prostą, a pozostałe dwa wierzchołki są punktami przecięcia prostej z osiami X i Y.
      <br><br><a href="https://pl.wikipedia.org/wiki/Odleg%C5%82o%C5%9B%C4%87_punktu_od_prostej)%C2%BD." target="_blank">Więcej informacji</a>
      <br><br><font size=2><a href="#top">Powrót na górę</a></font><br><hr>

      <!--
      <a id="#belongingness"></a>
      <h2>Check if a Point belongs to a Circle</h2>

      <iframe src="https://www.desmos.com/calculator/zabypv0non?embed" width="250px" height="250px" style="border: 1px solid #ccc" frameborder=0></iframe>
      <br><br>

      <font size = 4><u>For center-radius form of circles:</u></font><br><br><font size="5">
      Circle: (x - <input type="number" id="bj">)<sup>2</sup> + (y - <input type="number" id="bk">)<sup>2</sup> = <input type="number" id="bl"><sup>2</sup><br>
      Point: (<input type="number" id="bm">, <input type="number" id="bn">)<br><br></font>
      <font size=4>Result: <font id="xn"></font><br>
      Distance between the point and the middle of the circle: <font id="yn"></font></font>

      <br><br><br>

      <font size = 4><u>For general form of circles:</u></font><br><br><font size="5">
      Circle: x<sup>2</sup> + y<sup>2</sup> + <input type="number" id="bo">x + <input type="number" id="bp">y + <input type="number" id="br"> = 0<br>
      Point: (<input type="number" id="bs">, <input type="number" id="bt">)<br><br></font>
      <font size=4>Result: <font id="xo"></font><br>
      Distance between the point and the middle of the circle: <font id="yo"></font></font>

      <script>
        let bj = document.getElementById("bj");
        let bk = document.getElementById("bk");
        let bl = document.getElementById("bl");
        let bm = document.getElementById("bm");
        let bn = document.getElementById("bn");
        let bo = document.getElementById("bo");
        let bp = document.getElementById("bp");
        let br = document.getElementById("br");
        let bs = document.getElementById("bs");
        let bt = document.getElementById("bt");
        let xn = document.getElementById("xn");
        let yn = document.getElementById("yn");
        let xo = document.getElementById("xo");
        let yo = document.getElementById("yo");
        bj.addEventListener('input', function (evt) {
          if(Math.sqrt(Math.pow(parseFloat(bj.value)-parseFloat(bm.value),2) + Math.pow(parseFloat(bk.value)-parseFloat(bn.value),2)) > parseFloat(bl.value)) xn.innerText = "The point is outside the circle.";
          else if(Math.sqrt(Math.pow(parseFloat(bj.value)-parseFloat(bm.value),2) + Math.pow(parseFloat(bk.value)-parseFloat(bn.value),2)) = parseFloat(bl.value)) xn.innerText = "The point is on the circle.";
          else if(Math.sqrt(Math.pow(parseFloat(bj.value)-parseFloat(bm.value),2) + Math.pow(parseFloat(bk.value)-parseFloat(bn.value),2)) < parseFloat(bl.value)) xn.innerText = "The point is inside the circle.";
          else xn.innerText = "...";
          yn.innerText = Math.sqrt(Math.pow(parseFloat(bj.value)-parseFloat(bm.value),2) + Math.pow(parseFloat(bk.value)-parseFloat(bn.value),2));
        });
        bk.addEventListener('input', function (evt) {
          if(Math.sqrt(Math.pow(parseFloat(bj.value)-parseFloat(bm.value),2) + Math.pow(parseFloat(bk.value)-parseFloat(bn.value),2)) > parseFloat(bl.value)) xn.innerText = "The point is outside the circle.";
          else if(Math.sqrt(Math.pow(parseFloat(bj.value)-parseFloat(bm.value),2) + Math.pow(parseFloat(bk.value)-parseFloat(bn.value),2)) = parseFloat(bl.value)) xn.innerText = "The point is on the circle.";
          else if(Math.sqrt(Math.pow(parseFloat(bj.value)-parseFloat(bm.value),2) + Math.pow(parseFloat(bk.value)-parseFloat(bn.value),2)) < parseFloat(bl.value)) xn.innerText = "The point is inside the circle.";
          else xn.innerText = "...";
          yn.innerText = Math.sqrt(Math.pow(parseFloat(bj.value)-parseFloat(bm.value),2) + Math.pow(parseFloat(bk.value)-parseFloat(bn.value),2));
        });
        bl.addEventListener('input', function (evt) {
          if(Math.sqrt(Math.pow(parseFloat(bj.value)-parseFloat(bm.value),2) + Math.pow(parseFloat(bk.value)-parseFloat(bn.value),2)) > parseFloat(bl.value)) xn.innerText = "The point is outside the circle.";
          else if(Math.sqrt(Math.pow(parseFloat(bj.value)-parseFloat(bm.value),2) + Math.pow(parseFloat(bk.value)-parseFloat(bn.value),2)) = parseFloat(bl.value)) xn.innerText = "The point is on the circle.";
          else if(Math.sqrt(Math.pow(parseFloat(bj.value)-parseFloat(bm.value),2) + Math.pow(parseFloat(bk.value)-parseFloat(bn.value),2)) < parseFloat(bl.value)) xn.innerText = "The point is inside the circle.";
          else xn.innerText = "...";
          yn.innerText = Math.sqrt(Math.pow(parseFloat(bj.value)-parseFloat(bm.value),2) + Math.pow(parseFloat(bk.value)-parseFloat(bn.value),2));
        });
        bm.addEventListener('input', function (evt) {
          if(Math.sqrt(Math.pow(parseFloat(bj.value)-parseFloat(bm.value),2) + Math.pow(parseFloat(bk.value)-parseFloat(bn.value),2)) > parseFloat(bl.value)) xn.innerText = "The point is outside the circle.";
          else if(Math.sqrt(Math.pow(parseFloat(bj.value)-parseFloat(bm.value),2) + Math.pow(parseFloat(bk.value)-parseFloat(bn.value),2)) = parseFloat(bl.value)) xn.innerText = "The point is on the circle.";
          else if(Math.sqrt(Math.pow(parseFloat(bj.value)-parseFloat(bm.value),2) + Math.pow(parseFloat(bk.value)-parseFloat(bn.value),2)) < parseFloat(bl.value)) xn.innerText = "The point is inside the circle.";
          else xn.innerText = "...";
          yn.innerText = Math.sqrt(Math.pow(parseFloat(bj.value)-parseFloat(bm.value),2) + Math.pow(parseFloat(bk.value)-parseFloat(bn.value),2));
        });
        bn.addEventListener('input', function (evt) {
          if(Math.sqrt(Math.pow(parseFloat(bj.value)-parseFloat(bm.value),2) + Math.pow(parseFloat(bk.value)-parseFloat(bn.value),2)) > parseFloat(bl.value)) xn.innerText = "The point is outside the circle.";
          else if(Math.sqrt(Math.pow(parseFloat(bj.value)-parseFloat(bm.value),2) + Math.pow(parseFloat(bk.value)-parseFloat(bn.value),2)) = parseFloat(bl.value)) xn.innerText = "The point is on the circle.";
          else if(Math.sqrt(Math.pow(parseFloat(bj.value)-parseFloat(bm.value),2) + Math.pow(parseFloat(bk.value)-parseFloat(bn.value),2)) < parseFloat(bl.value)) xn.innerText = "The point is inside the circle.";
          else xn.innerText = "...";
          yn.innerText = Math.sqrt(Math.pow(parseFloat(bj.value)-parseFloat(bm.value),2) + Math.pow(parseFloat(bk.value)-parseFloat(bn.value),2));
        });
        bo.addEventListener('input', function (evt) {
          if(Math.sqrt(Math.pow((-parseFloat(bo.value)/2)-parseFloat(bs.value),2) + Math.pow((-parseFloat(bp.value)/2)-parseFloat(bt.value),2)) > Math.sqrt(Math.pow(parseFloat(bo.value),2)+Math.pow(parseFloat(bp.value),2)-4*parseFloat(br.value))/2) xo.innerText = "The point is outside the circle.";
          else if(Math.sqrt(Math.pow((-parseFloat(bo.value)/2)-parseFloat(bs.value),2) + Math.pow((-parseFloat(bp.value)/2)-parseFloat(bt.value),2)) = Math.sqrt(Math.pow(parseFloat(bo.value),2)+Math.pow(parseFloat(bp.value),2)-4*parseFloat(br.value))/2) xo.innerText = "The point is on the circle.";
          else if(Math.sqrt(Math.pow((-parseFloat(bo.value)/2)-parseFloat(bs.value),2) + Math.pow((-parseFloat(bp.value)/2)-parseFloat(bt.value),2)) < Math.sqrt(Math.pow(parseFloat(bo.value),2)+Math.pow(parseFloat(bp.value),2)-4*parseFloat(br.value))/2) xo.innerText = "The point is inside the circle.";
          yo.innerText = Math.sqrt(Math.pow((-parseFloat(bo.value)/2)-parseFloat(bs.value),2) + Math.pow((-parseFloat(bp.value)/2)-parseFloat(bt.value),2));
        });
        bp.addEventListener('input', function (evt) {
          if(Math.sqrt(Math.pow((-parseFloat(bo.value)/2)-parseFloat(bs.value),2) + Math.pow((-parseFloat(bp.value)/2)-parseFloat(bt.value),2)) > Math.sqrt(Math.pow(parseFloat(bo.value),2)+Math.pow(parseFloat(bp.value),2)-4*parseFloat(br.value))/2) xo.innerText = "The point is outside the circle.";
          else if(Math.sqrt(Math.pow((-parseFloat(bo.value)/2)-parseFloat(bs.value),2) + Math.pow((-parseFloat(bp.value)/2)-parseFloat(bt.value),2)) = Math.sqrt(Math.pow(parseFloat(bo.value),2)+Math.pow(parseFloat(bp.value),2)-4*parseFloat(br.value))/2) xo.innerText = "The point is on the circle.";
          else if(Math.sqrt(Math.pow((-parseFloat(bo.value)/2)-parseFloat(bs.value),2) + Math.pow((-parseFloat(bp.value)/2)-parseFloat(bt.value),2)) < Math.sqrt(Math.pow(parseFloat(bo.value),2)+Math.pow(parseFloat(bp.value),2)-4*parseFloat(br.value))/2) xo.innerText = "The point is inside the circle.";
          yo.innerText = Math.sqrt(Math.pow((-parseFloat(bo.value)/2)-parseFloat(bs.value),2) + Math.pow((-parseFloat(bp.value)/2)-parseFloat(bt.value),2));
        });
        br.addEventListener('input', function (evt) {
          if(Math.sqrt(Math.pow((-parseFloat(bo.value)/2)-parseFloat(bs.value),2) + Math.pow((-parseFloat(bp.value)/2)-parseFloat(bt.value),2)) > Math.sqrt(Math.pow(parseFloat(bo.value),2)+Math.pow(parseFloat(bp.value),2)-4*parseFloat(br.value))/2) xo.innerText = "The point is outside the circle.";
          else if(Math.sqrt(Math.pow((-parseFloat(bo.value)/2)-parseFloat(bs.value),2) + Math.pow((-parseFloat(bp.value)/2)-parseFloat(bt.value),2)) = Math.sqrt(Math.pow(parseFloat(bo.value),2)+Math.pow(parseFloat(bp.value),2)-4*parseFloat(br.value))/2) xo.innerText = "The point is on the circle.";
          else if(Math.sqrt(Math.pow((-parseFloat(bo.value)/2)-parseFloat(bs.value),2) + Math.pow((-parseFloat(bp.value)/2)-parseFloat(bt.value),2)) < Math.sqrt(Math.pow(parseFloat(bo.value),2)+Math.pow(parseFloat(bp.value),2)-4*parseFloat(br.value))/2) xo.innerText = "The point is inside the circle.";
          yo.innerText = Math.sqrt(Math.pow((-parseFloat(bo.value)/2)-parseFloat(bs.value),2) + Math.pow((-parseFloat(bp.value)/2)-parseFloat(bt.value),2));
        });
        bs.addEventListener('input', function (evt) {
          if(Math.sqrt(Math.pow((-parseFloat(bo.value)/2)-parseFloat(bs.value),2) + Math.pow((-parseFloat(bp.value)/2)-parseFloat(bt.value),2)) > Math.sqrt(Math.pow(parseFloat(bo.value),2)+Math.pow(parseFloat(bp.value),2)-4*parseFloat(br.value))/2) xo.innerText = "The point is outside the circle.";
          else if(Math.sqrt(Math.pow((-parseFloat(bo.value)/2)-parseFloat(bs.value),2) + Math.pow((-parseFloat(bp.value)/2)-parseFloat(bt.value),2)) = Math.sqrt(Math.pow(parseFloat(bo.value),2)+Math.pow(parseFloat(bp.value),2)-4*parseFloat(br.value))/2) xo.innerText = "The point is on the circle.";
          else if(Math.sqrt(Math.pow((-parseFloat(bo.value)/2)-parseFloat(bs.value),2) + Math.pow((-parseFloat(bp.value)/2)-parseFloat(bt.value),2)) < Math.sqrt(Math.pow(parseFloat(bo.value),2)+Math.pow(parseFloat(bp.value),2)-4*parseFloat(br.value))/2) xo.innerText = "The point is inside the circle.";
          yo.innerText = Math.sqrt(Math.pow((-parseFloat(bo.value)/2)-parseFloat(bs.value),2) + Math.pow((-parseFloat(bp.value)/2)-parseFloat(bt.value),2));
        });
        bt.addEventListener('input', function (evt) {
          if(Math.sqrt(Math.pow((-parseFloat(bo.value)/2)-parseFloat(bs.value),2) + Math.pow((-parseFloat(bp.value)/2)-parseFloat(bt.value),2)) > Math.sqrt(Math.pow(parseFloat(bo.value),2)+Math.pow(parseFloat(bp.value),2)-4*parseFloat(br.value))/2) xo.innerText = "The point is outside the circle.";
          else if(Math.sqrt(Math.pow((-parseFloat(bo.value)/2)-parseFloat(bs.value),2) + Math.pow((-parseFloat(bp.value)/2)-parseFloat(bt.value),2)) = Math.sqrt(Math.pow(parseFloat(bo.value),2)+Math.pow(parseFloat(bp.value),2)-4*parseFloat(br.value))/2) xo.innerText = "The point is on the circle.";
          else if(Math.sqrt(Math.pow((-parseFloat(bo.value)/2)-parseFloat(bs.value),2) + Math.pow((-parseFloat(bp.value)/2)-parseFloat(bt.value),2)) < Math.sqrt(Math.pow(parseFloat(bo.value),2)+Math.pow(parseFloat(bp.value),2)-4*parseFloat(br.value))/2) xo.innerText = "The point is inside the circle.";
          yo.innerText = Math.sqrt(Math.pow((-parseFloat(bo.value)/2)-parseFloat(bs.value),2) + Math.pow((-parseFloat(bp.value)/2)-parseFloat(bt.value),2));
        });
      </script>

      <hr>
      -->

      <a id="complex_division"></a>
      <h2>Dzielenie Zespolone (postać kanoniczna)</h2>

      <font size=5>
      z<sub>1</sub> = <input type="number" id="ac"> + <input type="number" id="ad">i
      <br>
      z<sub>2</sub> = <input type="number" id="ae"> + <input type="number" id="af">i
     </font>

      <br><br>
      <font size=4>Wynik: <font id="xe"></font><font id="ye"></font></font>

      <script>
        let ac = document.getElementById("ac");
        let ad = document.getElementById("ad");
        let ae = document.getElementById("ae");
        let af = document.getElementById("af");
        let xe = document.getElementById("xe");
        let ye = document.getElementById("ye");
        ac.addEventListener('input', function (evt) {
          xe.innerText = (parseFloat(ac.value)*parseFloat(ae.value) + parseFloat(ad.value)*parseFloat(af.value))/(Math.pow(parseFloat(ae.value),2)+Math.pow(parseFloat(af.value),2)) + " + ";
          ye.innerText = (parseFloat(ad.value)*parseFloat(ae.value) - parseFloat(ac.value)*parseFloat(af.value))/(Math.pow(parseFloat(ae.value),2)+Math.pow(parseFloat(af.value),2)) + "i";
        });
        ad.addEventListener('input', function (evt) {
          xe.innerText = (parseFloat(ac.value)*parseFloat(ae.value) + parseFloat(ad.value)*parseFloat(af.value))/(Math.pow(parseFloat(ae.value),2)+Math.pow(parseFloat(af.value),2)) + " + ";
          ye.innerText = (parseFloat(ad.value)*parseFloat(ae.value) - parseFloat(ac.value)*parseFloat(af.value))/(Math.pow(parseFloat(ae.value),2)+Math.pow(parseFloat(af.value),2)) + "i";
        });
        ae.addEventListener('input', function (evt) {
          xe.innerText = (parseFloat(ac.value)*parseFloat(ae.value) + parseFloat(ad.value)*parseFloat(af.value))/(Math.pow(parseFloat(ae.value),2)+Math.pow(parseFloat(af.value),2)) + " + ";
          ye.innerText = (parseFloat(ad.value)*parseFloat(ae.value) - parseFloat(ac.value)*parseFloat(af.value))/(Math.pow(parseFloat(ae.value),2)+Math.pow(parseFloat(af.value),2)) + "i";
        });
        af.addEventListener('input', function (evt) {
          xe.innerText = (parseFloat(ac.value)*parseFloat(ae.value) + parseFloat(ad.value)*parseFloat(af.value))/(Math.pow(parseFloat(ae.value),2)+Math.pow(parseFloat(af.value),2)) + " + ";
          ye.innerText = (parseFloat(ad.value)*parseFloat(ae.value) - parseFloat(ac.value)*parseFloat(af.value))/(Math.pow(parseFloat(ae.value),2)+Math.pow(parseFloat(af.value),2)) + "i";
        });
      </script>

      <br><br><br>Wyjaśnienie:
      <p>Dzielenie zespolone jest trudniejsze niż dodawanie, odejmowanie czy mnożenie (dlatego stworzyłem te narzędzie). Aby podzielić dwie liczby zespolone w postaci kanonicznej, należy pomnożyć liczbę w mianowniku przez jej <a href="https://pl.wikipedia.org/wiki/Sprz%C4%99%C5%BCenie_zespolone">sprzężenie zespolone</a>. Aby wartość ułamka pozostała taka sama, należy również pomnożyć licznik. Po uproszczeniu otrzymamy wynik.
      <br><br><a href="https://pl.khanacademy.org/math/precalculus/x9e81a4f98389efdf:complex/x9e81a4f98389efdf:complex-div/a/dividing-complex-numbers-review" target="_blank">Więcej informacji</a>
      <br><br><font size=2><a href="#top">Powrót na górę</a></font><br><hr>

      <a id="complex_division_polar"></a>
      <h2>Dzielenie Zespolone (postać biegunowa)</h2>

      <font size=5>
      z<sub>1</sub> = <input type="number" id="ag">*[cos(<input type="number" id="ah">°) + i*sin(<font id="ai"></font>)]
      <br>
      z<sub>2</sub> = <input type="number" id="aj">*[cos(<input type="number" id="ak">°) + i*sin(<font id="al"></font>)]
    </font>

      <br><br>
      <font size=4>Wynik: <font id="xf"></font><font id="yf"></font><font id="zf"></font></font>

      <script>
        let ag = document.getElementById("ag");
        let ah = document.getElementById("ah");
        let ai = document.getElementById("ai");
        let aj = document.getElementById("aj");
        let ak = document.getElementById("ak");
        let al = document.getElementById("al");
        let xf = document.getElementById("xf");
        let yf = document.getElementById("yf");
        let zf = document.getElementById("zf");
        ag.addEventListener('input', function (evt) {
          xf.innerText = parseFloat(ag.value)/parseFloat(aj.value) + "*[cos(";
          yf.innerText = parseFloat(ah.value) - parseFloat(ak.value) + "°) + i*sin(";
          zf.innerText = parseFloat(ah.value) - parseFloat(ak.value) + "°)]";
        });
        ah.addEventListener('input', function (evt) {
          ai.innerText = parseFloat(ah.value) + "°";
          xf.innerText = parseFloat(ag.value)/parseFloat(aj.value) + "*[cos(";
          yf.innerText = parseFloat(ah.value) - parseFloat(ak.value) + "°) + i*sin(";
          zf.innerText = parseFloat(ah.value) - parseFloat(ak.value) + "°)]";
        });
        aj.addEventListener('input', function (evt) {
          xf.innerText = parseFloat(ag.value)/parseFloat(aj.value) + "*[cos(";
          yf.innerText = parseFloat(ah.value) - parseFloat(ak.value) + "°) + i*sin(";
          zf.innerText = parseFloat(ah.value) - parseFloat(ak.value) + "°)]";
        });
        ak.addEventListener('input', function (evt) {
          al.innerText = parseFloat(ak.value) + "°";
          xf.innerText = parseFloat(ag.value)/parseFloat(aj.value) + "*[cos(";
          yf.innerText = parseFloat(ah.value) - parseFloat(ak.value) + "°) + i*sin(";
          zf.innerText = parseFloat(ah.value) - parseFloat(ak.value) + "°)]";
        });
      </script>

      <br><br><br>Wyjaśnienie:
      <p>Dzielenie liczb zespolonych w postaci biegunowej jest nieco prostsze niż w postaci kanonicznej. Moduły mogą zostać podzielone oddzielnie od reszty liczby. Argumenty funkcji cosinus i sinus można od siebie odjąć (kliknij w link poniżej aby dowiedzieć się, dlaczego).
      <br><br><a href="https://pl.wikipedia.org/wiki/Wz%C3%B3r_de_Moivre%E2%80%99a" target="_blank">Więcej informacji</a>
      <br><br><font size=2><a href="#top">Powrót na górę</a></font><br><hr>

      <a id="complex_rectangular_to_polar"></a>
      <h2>Konwerter liczb zespolonych z postaci kanonicznej do biegunowej</h2>

      <font size=5>
      z = <input type="number" id="am"> + <input type="number" id="an">i</font>

      <br><br>
      <font size=4>Wynik: <font id="xg"></font><font id="yg"></font></font><font id="zg"></font></font>

      <script>
        let am = document.getElementById("am");
        let an = document.getElementById("an");
        let xg = document.getElementById("xg");
        let yg = document.getElementById("yg");
        let zg = document.getElementById("zg");
        am.addEventListener('input', function (evt) {
          xg.innerText = Math.sqrt(Math.pow(parseFloat(am.value),2)+Math.pow(parseFloat(an.value),2)) + "*[cos(";
          if ((parseFloat(am.value) > 0) && (parseFloat(an.value) > 0)) { yg.innerText = Math.atan(parseFloat(an.value)/parseFloat(am.value))*180/Math.PI + "°) + i*sin("; }
          else if ((parseFloat(am.value) > 0) && (parseFloat(an.value) < 0)) { yg.innerText = Math.atan(parseFloat(an.value)/parseFloat(am.value))*180/Math.PI + 360 + "°) + i*sin("; }
          else { yg.innerText = Math.atan(parseFloat(an.value)/parseFloat(am.value))*180/Math.PI + 180 + "°) + i*sin("; }
          if ((parseFloat(am.value) > 0) && (parseFloat(an.value) > 0)) { zg.innerText = Math.atan(parseFloat(an.value)/parseFloat(am.value))*180/Math.PI + "°)]"; }
          else if ((parseFloat(am.value) > 0) && (parseFloat(an.value) < 0)) { zg.innerText = Math.atan(parseFloat(an.value)/parseFloat(am.value))*180/Math.PI + 360 + "°)]"; }
          else { zg.innerText = Math.atan(parseFloat(an.value)/parseFloat(am.value))*180/Math.PI + 180 + "°)]"; }
        });
        an.addEventListener('input', function (evt) {
          xg.innerText = Math.sqrt(Math.pow(parseFloat(am.value),2)+Math.pow(parseFloat(an.value),2)) + "*[cos(";
          if ((parseFloat(am.value) > 0) && (parseFloat(an.value) > 0)) { yg.innerText = Math.atan(parseFloat(an.value)/parseFloat(am.value))*180/Math.PI + "°) + i*sin("; }
          else if ((parseFloat(am.value) > 0) && (parseFloat(an.value) < 0)) { yg.innerText = Math.atan(parseFloat(an.value)/parseFloat(am.value))*180/Math.PI + 360 + "°) + i*sin("; }
          else { yg.innerText = Math.atan(parseFloat(an.value)/parseFloat(am.value))*180/Math.PI + 180 + "°) + i*sin("; }
          if ((parseFloat(am.value) > 0) && (parseFloat(an.value) > 0)) { zg.innerText = Math.atan(parseFloat(an.value)/parseFloat(am.value))*180/Math.PI + "°)]"; }
          else if ((parseFloat(am.value) > 0) && (parseFloat(an.value) < 0)) { zg.innerText = Math.atan(parseFloat(an.value)/parseFloat(am.value))*180/Math.PI + 360 + "°)]"; }
          else { zg.innerText = Math.atan(parseFloat(an.value)/parseFloat(am.value))*180/Math.PI + 180 + "°)]"; }
        });
      </script>

      <br><br><br>Wyjaśnienie:
      <p>Aby zamienić liczbę zespoloną o postaci kanonicznej do postaci biegunowej, należy obliczyć moduł i argument liczby zespolonej. Aby obliczyć moduł, zastosuj Twierdzenie Pitagorasa (dla liczby zespolonej z = a + bi oraz modułu r, r<sup>2</sup> = a<sup>2</sup> + b<sup>2</sup>). Aby obliczyć argument, zastosuj funkcję tangens (tg θ = b/a).
      <br><br><a href="https://pl.wikibooks.org/wiki/Liczby_zespolone/Posta%C4%87_trygonometryczna" target="_blank">Więcej informacji</a>
      <br><br><font size=2><a href="#top">Powrót na górę</a></font><br><hr>

      <a id="complex_polar_to_rectangular"></a>
      <h2>Konwerter liczb zespolonych z postaci biegunowej do postaci kanonicznej</h2>

      <font size=5>z = <input type="number" id="ao">*[cos(<input type="number" id="ap">°) + i*sin(<font id="ar"></font>°)]</font>

      <br><br>
      <font size=4>Wynik: <font id="xh"></font><font id="yh"></font></font>

      <script>
        let ao = document.getElementById("ao");
        let ap = document.getElementById("ap");
        let ar = document.getElementById("ar");
        let xh = document.getElementById("xh");
        let yh = document.getElementById("yh");
        ao.addEventListener('input', function (evt) {
          xh.innerText = parseFloat(ao.value)*Math.cos(parseFloat(ap.value)*Math.PI/180) + " + ";
          yh.innerText = parseFloat(ao.value)*Math.sin(parseFloat(ap.value)*Math.PI/180) + "i";
        });
        ap.addEventListener('input', function (evt) {
          xh.innerText = parseFloat(ao.value)*Math.cos(parseFloat(ap.value)*Math.PI/180) + " + ";
          yh.innerText = parseFloat(ao.value)*Math.sin(parseFloat(ap.value)*Math.PI/180) + "i";
          ar.innerText = parseFloat(ap.value);
        });
      </script>

      <br><br><br>Wyjaśnienie:
      <p>Aby zamienić liczbę zespoloną o postaci biegunowej do postaci kanonicznej, zastosuj własności trójkąta prostokątnego utworzonego ze współrzędnych x i y oraz modułu. Innymi słowy, zastosuj definicję cosinusa aby obliczyć x, oraz sinusa aby obliczyć y.
      <br><br><a href="https://matematykaszkolna.pl/strona/397.html" target="_blank">Więcej informacji</a>
      <br><br><font size=2><a href="#top">Powrót na górę</a></font><br><hr>

      <a id="external"></a>
      <h2>Linki zewnętrzne</h2>
      <p>Oto kilka świetnych narzędzi matematycznych stworzonych przez innych ludzi, które bardzo polecam.

      <p><br>
      <a href="https://www.desmos.com/calculator" target="_blank"><img src="desmos icon.png">
      <h3>Kalkulator Graficzny Desmos</a></h3>
      Desmos jest świetnym narzędziem dającym możliwość rysowania wykresów funkcji, równań, nierówności, tablic z danymi, obliczania wyrażeń, badanie zmian z parametrami i więcej. Można się zarejestrować aby zapisywać i udostępniać swoje wykresy. Używałem już tego programu przez ponad rok, a stworzone przeze mnie wykresy można zobaczyć w sekcji <a href="graphs_pl.html">Wykresy</a>.

      <p><br>
      <a href="https://www.wolframalpha.com/" target="_blank"><img src="wolframalpha icon.png" height="125" width="256">
      <h3>WolframAlpha</a></h3>
      WolframAlpha jest unikalnym narzędziem do obliczania i dostarczania wiedzy, nie tylko z zakresu matematyki. Potrafi między innymi rozwiązać jakiekolwiek równanie lub narysować wykres jakiejkolwiek funkcji.

      <p><br><br>
      Jeśli znasz jakieś inne świetnie narzędzia matematyczne, możesz mi o nich powiedzieć i zastanowię się nad zlinkowaniem ich tutaj.

      <br><br>
      <br><br><font size=2><a href="#top">Powrót na górę</a></font><br><br>

  </div>
</body>
